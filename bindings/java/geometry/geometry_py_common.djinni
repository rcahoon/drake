# @file This contains all of the various types in the drake::geometry namespace
# that represent the "core" geometry concepts: instances, frames, properties.
# These don't depend on any of geometry's computational structure, but, instead,
# represent the input values to all of those computations. They can be found in
# the pydrake.geometry module.

#include "drake/bindings/pydrake/common/default_scalars_pybind.h"
#include "drake/bindings/pydrake/common/identifier_pybind.h"
#include "drake/bindings/pydrake/common/serialize_pybind.h"
#include "drake/bindings/pydrake/common/value_pybind.h"
#include "drake/bindings/pydrake/documentation_pybind.h"
#include "drake/geometry/collision_filter_declaration.h"
#include "drake/geometry/collision_filter_manager.h"
#include "drake/geometry/geometry_frame.h"
#include "drake/geometry/geometry_ids.h"
#include "drake/geometry/geometry_instance.h"
#include "drake/geometry/geometry_properties.h"
#include "drake/geometry/geometry_roles.h"
#include "drake/geometry/geometry_version.h"
#include "drake/geometry/proximity_properties.h"
#include "drake/geometry/shape_specification.h"

CollisionFilterDeclaration = bind `drake::geometry::CollisionFilterDeclaration` @ "drake/geometry/collision_filter_declaration.h" {
    static init(): CollisionFilterDeclaration `
        return std::make_shared<CollisionFilterDeclaration>();
    `;
    AllowBetween(set_A: GeometrySet, set_B: GeometrySet): CollisionFilterDeclaration;
    AllowWithin(geometry_set: GeometrySet): CollisionFilterDeclaration;
    ExcludeBetween(set_A: GeometrySet, set_B: GeometrySet): CollisionFilterDeclaration;
    ExcludeWithin(geometry_set: GeometrySet): CollisionFilterDeclaration;
}

CollisionFilterManager = bind `drake::geometry::CollisionFilterManager` @ "drake/geometry/collision_filter_manager.h" {
    Apply(declaration: CollisionFilterDeclaration): void;
    ApplyTransient(declaration: CollisionFilterDeclaration): FilterId
    RemoveDeclaration(filter_id: FilterId): bool;
    has_transient_history(): bool;
    IsActive(filter_id: FilterId): bool;
}

GeometryFrame = bind `drake::geometry::GeometryFrame` @ "drake/geometry/geometry_frame.h" {
    static init(frame_name: string, frame_group_id: i32>): GeometryFrame `
        return std::make_shared<GeometryFrame>(frame_name, frame_group_id);
    `;
    id(): FrameId;
    name(): string;
    frame_group(): i32;
    $DefCopyAndDeepCopy
}

GeometryInstance = bind `drake::geometry::GeometryInstance` @ "drake/geometry/geometry_instance.h" {
    static init(X_PG: math::RigidTransform<double>, shape: Shape, name: string): GeometryInstance `
        return std::make_shared<GeometryInstance>(*X_PG, *shape, name);
    `;
    id(): GeometryId;
    pose(): math::RigidTransform<double> ref_return_value keep_alive(0, 1);
    set_pose(X_PG: math::RigidTransform<double>): void;
    shape(): Shape ref_return_value keep_alive(0, 1);
    name(): string;
    set_name(name: string): void;
    set_proximity_properties(properties: ProximityProperties): void;
    set_illustration_properties(properties: IllustrationProperties): void;
    set_perception_properties(properties: PerceptionProperties): void;
    mutable_proximity_properties(): ProximityProperties ref_return_value keep_alive(0, 1);
    proximity_properties(): ProximityProperties ref_return_value keep_alive(0, 1);
    mutable_illustration_properties(): IllustrationProperties ref_return_value keep_alive(0, 1);
    illustration_properties(): IllustrationProperties ref_return_value keep_alive(0, 1);
    mutable_perception_properties(): PerceptionProperties ref_return_value keep_alive(0, 1);
    perception_properties(): PerceptionProperties ref_return_value keep_alive(0, 1);
    $DefCopyAndDeepCopy
}
GeometryProperties = bind `drake::geometry::GeometryProperties` @ "drake/geometry/geometry_properties.h" {
    HasGroup(group_name: string): bool;
    num_groups(): i32;
    GetPropertiesInGroup(group_name: string): map<string, AbstractValue> `
        std::unordered_map<std::string, djinni::SharedPtr<AbstractValue>> out;
        for (auto& [name, abstract] : self->GetPropertiesInGroup(group_name)) {
            auto ref = djinni::DisconnectReference<djinni::SharedPtr<AbstractValue>>::apply(abstract);
            ref.keepAlive(self);
            out[name] = ref;
        }
        return out;
    `;
    GetGroupNames(): set<string>;
    AddProperty(group_name: string, name: string, value: AbstractValue) `
        self->AddPropertyAbstract(group_name, name, *value);
    `;
    UpdateProperty(group_name: string, name: string, value: AbstractValue) `
        self->UpdatePropertyAbstract(group_name, name, *value);
    `;
    HasProperty(group_name: string): bool;
    GetProperty(group_name: string, name: string): AbstractValue ref_return_value `
        return self->GetPropertyAbstract(group_name, name);
    `;
    GetPropertyOrDefault(group_name: string, name: string, default_value: AbstractValue): AbstractValue `
        //TODO: For now, ignore typing.
        if (self->HasProperty(group_name, name)) {
            auto ref = self->GetPropertyAbstract(group_name, name);
            auto ref = djinni::DisconnectReference<djinni::SharedPtr<AbstractValue>>::apply(abstract);
            ref.keepAlive(self);
            return ret;
        } else {
            return default_value;
        }
    `;
    RemoveProperty(group_name: string, name: string): bool;
    static default_group_name(): string;
    # Returns formatted string.
    toString(): string `
        std::stringstream ss;
        ss << *self;
        return ss.str();
    `;
}
GeometrySet = bind `drake::geometry::GeometrySet` @ "drake/geometry/geometry_set.h" {
    static init(): GeometrySet `
        return std::make_shared<GeometrySet>();
    `;
    static init(geometry_id: GeometryId): GeometrySet `
        return std::make_shared<GeometrySet>(geometry_id);
    `;
    static init(frame_id: FrameId): GeometrySet `
        return std::make_shared<GeometrySet>(frame_id);
    `;
    static init(geometry_ids: list<GeometryId>) `
        return std::make_shared<GeometrySet>(geometry_ids);
    `;
    static init(frame_ids: std::vector<FrameId>) `
        return std::make_shared<GeometrySet>(frame_ids);
    `;
    static init(geometry_ids: list<GeometryId>, frame_ids: std::vector<FrameId>) `
        return std::make_shared<GeometrySet>(geometry_ids, frame_ids);
    `;
    Add(geometry_id: GeometryId): void {
        self->Add(geometry_id);
    `;
    Add(frame_id: FrameId) `
        self->Add(frame_id);
    `;
    Add(geometry_ids: list<GeometryId>): void `
        self->Add(geometry_ids);
    `;
    Add(frame_ids: list<FrameId> ) {
        self->Add(frame_ids);
    `;
    Add(geometry_ids: list<GeometryId>, frame_ids: list<FrameId>) `
        self->Add(geometry_ids, frame_ids);
    `;
}

GeometryVersion = bind `drake::geometry::GeometryVersion` @ "drake/geometry/geometry_set.h" {
    static init(): GeometryVersion `
        return std::make_shared<GeometryVersion>();
    `;
    # Creates a copy of the GeometryVersion.
    static init(other: GeometryVersion): GeometryVersion `
        return std::make_shared<GeometryVersion>(*other);
    `
    IsSameAs(other: GeometryVersion, role: Role): bool;
    $DefCopyAndDeepCopy
}

$BindIdentifier(FilterId)
$BindIdentifier(SourceId)
$BindIdentifier(FrameId)
$BindIdentifier(GeometryId)

IllustrationProperties = bind as GeometryProperties `drake::geometry::IllustrationProperties` @ "drake/geometry/geometry_roles.h" {
    static init(): IllustrationProperties `
        return std::make_shared<IllustrationProperties>();
    `;
    # Creates a copy of the properties
    static init(other: IllustrationProperties): IllustrationProperties `
        return std::make_shared<IllustrationProperties>();
    `;
    $DefCopyAndDeepCopy
}

    py::class_<PerceptionProperties, GeometryProperties> cls(
        m, "PerceptionProperties", doc.PerceptionProperties.doc);
    cls.def(py::init(), doc.PerceptionProperties.ctor.doc)
        .def(py::init<const PerceptionProperties&>(), py::arg("other"),
            "Creates a copy of the properties");
    $DefCopyAndDeepCopy
}

  // ProximityProperties
  {
    py::class_<ProximityProperties, GeometryProperties> cls(
        m, "ProximityProperties", doc.ProximityProperties.doc);
    cls.def(py::init(), doc.ProximityProperties.ctor.doc)
        .def(py::init<const ProximityProperties&>(), py::arg("other"),
            "Creates a copy of the properties");
    DefCopyAndDeepCopy(&cls);
  }

  // Rgba
  {
    using Class = Rgba;
    constexpr auto& cls_doc = doc.Rgba;
    py::class_<Class> cls(m, "Rgba", cls_doc.doc);
    cls  // BR
        .def(py::init<>(), cls_doc.ctor.doc_0args)
        .def(py::init<double, double, double, double>(), py::arg("r"),
            py::arg("g"), py::arg("b"), py::arg("a") = 1.0,
            cls_doc.ctor.doc_4args)
        .def("r", &Class::r, cls_doc.r.doc)
        .def("g", &Class::g, cls_doc.g.doc)
        .def("b", &Class::b, cls_doc.b.doc)
        .def("a", &Class::a, cls_doc.a.doc)
        .def("set",
            py::overload_cast<double, double, double, double>(&Class::set),
            py::arg("r"), py::arg("g"), py::arg("b"), py::arg("a") = 1.0,
            cls_doc.set.doc_4args)
        .def("set",
            py::overload_cast<const Eigen::Ref<const Eigen::VectorXd>&>(
                &Class::set),
            py::arg("rgba"), cls_doc.set.doc_1args)
        .def("update", &Class::update, py::arg("r") = py::none(),
            py::arg("g") = py::none(), py::arg("b") = py::none(),
            py::arg("a") = py::none(), cls_doc.update.doc)
        .def(py::self == py::self)
        .def(py::self != py::self)
        .def(py::self * py::self)
        .def("scale_rgb", &Class::scale_rgb, py::arg("scale"),
            cls_doc.scale_rgb.doc)
        .def("__repr__", [](const Class& self) {
          return py::str("Rgba(r={}, g={}, b={}, a={})")
              .format(self.r(), self.g(), self.b(), self.a());
        });
    DefAttributesUsingSerialize(&cls);
    cls.def_property("rgba",
        // The Serialize-based binding skips the validity checking; we'll
        // add it back here by re-binding the property getter and setter.
        &Class::rgba,
        py::overload_cast<const Eigen::Ref<const Eigen::VectorXd>&>(
            &Class::set),
        "The RGBA value as a property (as np.ndarray).");
    DefCopyAndDeepCopy(&cls);
    AddValueInstantiation<Rgba>(m);
  }

  // Role enumeration
  {
    constexpr auto& cls_doc = doc.Role;
    py::enum_<Role>(m, "Role", py::arithmetic(), cls_doc.doc)
        .value("kUnassigned", Role::kUnassigned, cls_doc.kUnassigned.doc)
        .value("kProximity", Role::kProximity, cls_doc.kProximity.doc)
        .value("kIllustration", Role::kIllustration, cls_doc.kIllustration.doc)
        .value("kPerception", Role::kPerception, cls_doc.kPerception.doc);
  }

  // RoleAssign enumeration
  {
    constexpr auto& cls_doc = doc.RoleAssign;
    using Class = RoleAssign;
    py::enum_<Class>(m, "RoleAssign", cls_doc.doc)
        .value("kNew", Class::kNew, cls_doc.kNew.doc)
        .value("kReplace", Class::kReplace, cls_doc.kReplace.doc);
  }

  // Shape constructors - ordered alphabetically and not in the order given in
  // shape_specification.h
  {
    py::class_<Shape> shape_cls(m, "Shape", doc.Shape.doc);
    DefClone(&shape_cls);

    py::class_<Box, Shape>(m, "Box", doc.Box.doc)
        .def(py::init<double, double, double>(), py::arg("width"),
            py::arg("depth"), py::arg("height"), doc.Box.ctor.doc_3args)
        .def(py::init<const Vector3<double>&>(), py::arg("measures"),
            doc.Box.ctor.doc_1args)
        .def("width", &Box::width, doc.Box.width.doc)
        .def("depth", &Box::depth, doc.Box.depth.doc)
        .def("height", &Box::height, doc.Box.height.doc)
        .def("size", &Box::size, py_rvp::reference_internal, doc.Box.size.doc)
        .def(py::pickle(
            [](const Box& self) {
              return std::make_tuple(self.width(), self.depth(), self.height());
            },
            [](std::tuple<double, double, double> dims) {
              return Box(
                  std::get<0>(dims), std::get<1>(dims), std::get<2>(dims));
            }));

    py::class_<Capsule, Shape>(m, "Capsule", doc.Capsule.doc)
        .def(py::init<double, double>(), py::arg("radius"), py::arg("length"),
            doc.Capsule.ctor.doc_2args)
        .def(py::init<const Vector2<double>&>(), py::arg("measures"),
            doc.Capsule.ctor.doc_1args)
        .def("radius", &Capsule::radius, doc.Capsule.radius.doc)
        .def("length", &Capsule::length, doc.Capsule.length.doc)
        .def(py::pickle(
            [](const Capsule& self) {
              return std::make_pair(self.radius(), self.length());
            },
            [](std::pair<double, double> dims) {
              return Capsule(dims.first, dims.second);
            }));

    py::class_<Convex, Shape> convex_cls(m, "Convex", doc.Convex.doc);
    convex_cls
        .def(py::init<std::string, double>(), py::arg("filename"),
            py::arg("scale") = 1.0, doc.Convex.ctor.doc)
        .def("filename", &Convex::filename, doc.Convex.filename.doc)
        .def("extension", &Convex::extension, doc.Convex.extension.doc)
        .def("scale", &Convex::scale, doc.Convex.scale.doc)
        .def(py::pickle(
            [](const Convex& self) {
              return std::make_pair(self.filename(), self.scale());
            },
            [](std::pair<std::string, double> info) {
              return Convex(info.first, info.second);
            }));

    py::class_<Cylinder, Shape>(m, "Cylinder", doc.Cylinder.doc)
        .def(py::init<double, double>(), py::arg("radius"), py::arg("length"),
            doc.Cylinder.ctor.doc_2args)
        .def(py::init<const Vector2<double>&>(), py::arg("measures"),
            doc.Cylinder.ctor.doc_1args)
        .def("radius", &Cylinder::radius, doc.Cylinder.radius.doc)
        .def("length", &Cylinder::length, doc.Cylinder.length.doc)
        .def(py::pickle(
            [](const Cylinder& self) {
              return std::make_pair(self.radius(), self.length());
            },
            [](std::pair<double, double> dims) {
              return Cylinder(dims.first, dims.second);
            }));

    py::class_<Ellipsoid, Shape>(m, "Ellipsoid", doc.Ellipsoid.doc)
        .def(py::init<double, double, double>(), py::arg("a"), py::arg("b"),
            py::arg("c"), doc.Ellipsoid.ctor.doc_3args)
        .def(py::init<const Vector3<double>&>(), py::arg("measures"),
            doc.Ellipsoid.ctor.doc_1args)
        .def("a", &Ellipsoid::a, doc.Ellipsoid.a.doc)
        .def("b", &Ellipsoid::b, doc.Ellipsoid.b.doc)
        .def("c", &Ellipsoid::c, doc.Ellipsoid.c.doc)
        .def(py::pickle(
            [](const Ellipsoid& self) {
              return std::make_tuple(self.a(), self.b(), self.c());
            },
            [](std::tuple<double, double, double> dims) {
              return Ellipsoid(
                  std::get<0>(dims), std::get<1>(dims), std::get<2>(dims));
            }));

    py::class_<HalfSpace, Shape>(m, "HalfSpace", doc.HalfSpace.doc)
        .def(py::init<>(), doc.HalfSpace.ctor.doc)
        .def_static("MakePose", &HalfSpace::MakePose, py::arg("Hz_dir_F"),
            py::arg("p_FB"), doc.HalfSpace.MakePose.doc);

    py::class_<Mesh, Shape> mesh_cls(m, "Mesh", doc.Mesh.doc);
    mesh_cls
        .def(py::init<std::string, double>(), py::arg("filename"),
            py::arg("scale") = 1.0, doc.Mesh.ctor.doc)
        .def("filename", &Mesh::filename, doc.Mesh.filename.doc)
        .def("extension", &Mesh::extension, doc.Mesh.extension.doc)
        .def("scale", &Mesh::scale, doc.Mesh.scale.doc)
        .def(py::pickle(
            [](const Mesh& self) {
              return std::make_pair(self.filename(), self.scale());
            },
            [](std::pair<std::string, double> info) {
              return Mesh(info.first, info.second);
            }));

    py::class_<Sphere, Shape>(m, "Sphere", doc.Sphere.doc)
        .def(py::init<double>(), py::arg("radius"), doc.Sphere.ctor.doc)
        .def("radius", &Sphere::radius, doc.Sphere.radius.doc)
        .def(py::pickle([](const Sphere& self) { return self.radius(); },
            [](const double radius) { return Sphere(radius); }));

    py::class_<MeshcatCone, Shape>(m, "MeshcatCone", doc.MeshcatCone.doc)
        .def(py::init<double, double, double>(), py::arg("height"),
            py::arg("a") = 1.0, py::arg("b") = 1.0,
            doc.MeshcatCone.ctor.doc_3args)
        .def(py::init<const Vector3<double>&>(), py::arg("measures"),
            doc.MeshcatCone.ctor.doc_1args)
        .def("height", &MeshcatCone::height, doc.MeshcatCone.height.doc)
        .def("a", &MeshcatCone::a, doc.MeshcatCone.a.doc)
        .def("b", &MeshcatCone::b, doc.MeshcatCone.b.doc)
        .def(py::pickle(
            [](const MeshcatCone& self) {
              return std::make_tuple(self.height(), self.a(), self.b());
            },
            [](std::tuple<double, double, double> params) {
              return MeshcatCone(std::get<0>(params), std::get<1>(params),
                  std::get<2>(params));
            }));
  }

  m.def("CalcVolume", &CalcVolume, py::arg("shape"), doc.CalcVolume.doc);

  m.def("MakePhongIllustrationProperties", &MakePhongIllustrationProperties,
      py_rvp::reference_internal, py::arg("diffuse"),
      doc.MakePhongIllustrationProperties.doc);

  m.def("AddContactMaterial",
      py::overload_cast<const std::optional<double>&,
          const std::optional<double>&,
          const std::optional<multibody::CoulombFriction<double>>&,
          ProximityProperties*>(&AddContactMaterial),
      py::arg("dissipation"), py::arg("point_stiffness"), py::arg("friction"),
      py::arg("properties"), doc.AddContactMaterial.doc);
  // The C++ function does not offer default arguments, but it's convenient to
  // default the optional arguments to None in Python because a caller can use
  // named arguments to disambiguate which arguments get which values.
  m.def(
      "AddContactMaterial",
      [](ProximityProperties* properties,
          const std::optional<double>& dissipation,
          const std::optional<double>& point_stiffness,
          const std::optional<multibody::CoulombFriction<double>>& friction) {
        AddContactMaterial(dissipation, point_stiffness, friction, properties);
      },
      py::arg("properties"), py::arg("dissipation") = std::nullopt,
      py::arg("point_stiffness") = std::nullopt,
      py::arg("friction") = std::nullopt, doc.AddContactMaterial.doc);
}

// Test-only code.
namespace testing {
// For use with `test_geometry_properties_cpp_types`.
template <typename T>
void DefGetPropertyCpp(py::module m) {
  auto func = [](const geometry::GeometryProperties& properties,
                  const std::string& group, const std::string& name) {
    return properties.GetProperty<T>(group, name);
  };
  AddTemplateFunction(m, "GetPropertyCpp", func, GetPyParam<T>());
}

// For use with test_proximity_properties. The hydroelastic compliance type is
// internal. But we want to test that the compliance type has been successfully
// defined in set of properties. If we ever move HydroelasticType out of
// internal and bind it, we can eliminate this helper.
//
// Return true if the properties indicate being compliant, false if rigid, and
// throws if the property isn't set at all (or set to undefined).
bool PropertiesIndicateCompliantHydro(
    const geometry::ProximityProperties& props) {
  using geometry::internal::HydroelasticType;
  const HydroelasticType hydro_type =
      props.GetPropertyOrDefault(geometry::internal::kHydroGroup,
          geometry::internal::kComplianceType, HydroelasticType::kUndefined);
  if (hydro_type == HydroelasticType::kUndefined) {
    throw std::runtime_error("No specification of rigid or compliant");
  }
  return hydro_type == HydroelasticType::kSoft;
}

void def_testing_module(py::module m) {
  // The get_constant_id() returns a fresh object every time, but always with
  // the same underlying get_value().
  const auto constant_id = geometry::FilterId::get_new_id();
  m.def("get_constant_id", [constant_id]() { return constant_id; });

  m.def("PropertiesIndicateCompliantHydro", &PropertiesIndicateCompliantHydro);

  // For use with `test_geometry_properties_cpp_types`.
  DefGetPropertyCpp<std::string>(m);
  DefGetPropertyCpp<bool>(m);
  DefGetPropertyCpp<double>(m);
}
}  // namespace testing

}  // namespace

void DefineGeometryCommon(py::module m) {
  m.doc() = "Bindings for `drake::geometry`";

  DoScalarIndependentDefinitions(m);
  testing::def_testing_module(m.def_submodule("_testing"));
}

}  // namespace pydrake
}  // namespace drake
